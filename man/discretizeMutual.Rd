% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/discretizeMutual.R
\name{discretizeMutual}
\alias{discretizeMutual}
\title{Iterative dynamic programming for (conditional) mutual information through optimized discretization.}
\usage{
discretizeMutual(X, Y, matrixU = NULL, maxbins = NULL, cplx = "nml",
  effN = NULL, is_discrete = NULL, plot = T)
}
\arguments{
\item{X}{[a vector]
A vector that contains the observational data of the first variable.}

\item{Y}{[a vector]
A vector that contains the observational data of the second variable.}

\item{matrixU}{[a numeric matrix]
The matrix with the observations of as many columns as conditioning variables.}

\item{maxbins}{[an int]
The maximum number of bins desired in the discretization. A lower number makes the computation faster, a higher
number allows finer discretization (50 by default).}

\item{cplx}{[a string]
The complexity used in the dynamic programming. Either "mdl" for Minimum description Length or
"nml" for Normalized Maximum Likelihood, which is less costly in the finite sample case and
will allow more bins than mdl.}

\item{is_discrete}{[a vector of booleans]
Specify if each variable is to be treated as discrete (TRUE) or continuous (FALSE) in a
logical vector of length ncol(matrixU)+2, in the order [X, Y, U1, U2...]. By
default all variables are treated as continuous.}

\item{plot}{[a boolean]
Specify if the XY joint space with discretization scheme is to be plotted or not (requires
ggplot2 and gridExtra).}

\item{Neff}{[an int]
The number of effective samples. When there is significant autocorrelation in the samples you may
want to specify a number of effective samples that is lower than the number of points in the distribution.}
}
\description{
This function chooses cutpoints in the input distributions by maximizing the mutual
information minus a complexity cost (computed as BIC or with the Normalized Maximum Likelihood ). The
(conditional) mutual information computed on the optimized discretized distributions effectively approaches
the mutual information computed on the original continuous variables.
}
\details{
For a pair of variables \eqn{X} and \eqn{Y}, the algorithm will in turn choose cutpoints on \eqn{X}
then on \eqn{Y}, maximizing \eqn{I(X_{d};Y_{d}) - cplx(X_{d};Y_{d})} where \eqn{cplx(X_{d};Y_{d})} is the
complexity cost of the considered discretizations of \eqn{X} and \eqn{Y} (see Affeldt 2016).
When the value \eqn{I(X_{d};Y_{d})} is stable between two iterations the discretization scheme of
\eqn{X_{d}} and \eqn{Y_{d}} is returned as well as \eqn{I(X_{d};Y_{d})} and \eqn{I(X_{d};Y_{d})-cplx(X_{d};Y_{d})}.

With a set of conditioning variables \eqn{U}, the discretization scheme maximizes each term of the sum
\eqn{I(X;Y|U) \sim 0.5*(I(X_{d};Y_{d},U_{d}) - I(X_{d};U_{d}) + I(Y_{d};X_{d},U_{d}) - I(Y_{d};U_{d}))}.

Discrete variables can be passed as factors will be used "as is" to maximize each term.
}
\examples{
library(miic)

\dontrun{
N <- 1000
# Dependence, conditional independence
Z <- runif(N)
X <- Z*2+rnorm(N,sd=0.2)
Y <- Z*2+rnorm(N,sd=0.2)
res <- discretizeMutual(X, Y, plot=T)
cat("I(X;Y) =",res$info)
res <- discretizeMutual(X, Y, matrixU=matrix(Z, ncol=1), plot=T)
cat("I(X;Y|Z) =",res$info)

# Conditional independence with categorical conditioning variable
Z <- sample(1:3, N, replace=T)
X <- -as.numeric(Z==1) + as.numeric(Z==2) + 0.2*rnorm(N)
Y <- as.numeric(Z==1) + as.numeric(Z==2) + 0.2*rnorm(N)
res <- miic::discretizeMutual(X, Y, cplx = 'nml')
cat("I(X;Y) =", res$info)
res <- miic::discretizeMutual(X, Y, matrix(Z,ncol=1), is_discrete = c(F,F,T))
cat("I(X;Y|Z) =", res$info)


# Independence, conditional dependence
X <- runif(N)
Y <- runif(N)
Z <- X+Y
res <- discretizeMutual(X, Y, plot=T)
cat("I(X;Y) =",res$info)
res <- discretizeMutual(X, Y, matrixU = matrix(Z, ncol=1), plot=T)
cat("I(X;Y|Z) =",res$info)
}
}
\references{
\itemize{
\item verny et al., \emph{plos comp. bio. 2017.}
\item Affeldt et al., \emph{Bioinformatics 2016}
}
}
