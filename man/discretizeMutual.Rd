% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/discretizeMutual.R
\name{discretizeMutual}
\alias{discretizeMutual}
\title{Discretize two distributions with or without conditioning variables}
\usage{
discretizeMutual(myDist1 = NULL, myDist2 = NULL, matrixU = NULL,
  maxbins = NULL, initbins = NULL, cplx = "nml", pxy = 1,
  is_discrete = NULL, plot = T)
}
\arguments{
\item{myDist1}{[a vector]
A vector that contains the observational data of the first variable.}

\item{myDist2}{[a vector]
A vector that contains the observational data of the second variable.}

\item{matrixU}{[a numeric matrix]
The matrix containing the values of the conditioning variables with as many columns as variables.}

\item{maxbins}{[an int] 
The maximum number of bins desired in the discretization.}

\item{initbins}{[an int]
The number of bins for the initial discretization.}

\item{cplx}{[a string]
The complexity used in the dynamic programming. Either "mdl" for Minimum description Length or 
"nml" for Normalized Maximum Likelihood, which is less costly in the finite sample case and 
will allow more bins than mdl.}

\item{is_discrete}{[a vector of booleans]
Specify if each distribution is to be treated as discrete (TRUE) or continuous (FALSE) in a 
logical vector of length ncol(matrixU)+2, in the order [myDist1, myDist2, U1, U2...]. By 
default all variables are treated as continuous.}
}
\value{
A list with the two vectors containing the cutpoints for each variable : cutpoints1 
corresponds to myDist1, cutpoints2 corresponds to myDist2.
}
\description{
This function chooses cutpoints in the input distributions by maximizing the mutual
information minus a complexity cost (computed as BIC or with normalized maximum likelihood). The 
(conditional) mutual information computed on the discretized distributions effectively approaches 
the mutual information computed on the original continuous variables.
}
\details{
For a pair of variables \eqn{X} and \eqn{Y}, the algorithm will in turn choose cutpoints on \eqn{X}
then on \eqn{Y}, maximizing \eqn{I(X_{d};Y_{d}) - cplx(X_{d};Y_{d})} #' where \eqn{cplx(X_{d};Y_{d})} is the 
complexity cost of the considered discretizations.
When the value \eqn{I(X_{d};Y_{d})} is stable between two iterations the discretization scheme of 
\eqn{X_{d}} and \eqn{Y_{d}} is returned as well as \eqn{I(X_{d};Y_{d})} and \eqn{I(X_{d};Y_{d})-cplx(X;Y)}.
With conditioning variable \eqn{U}, the discretization scheme maximizes each term of the sum 
\eqn{I(X;Y|U) \sim 0.5*(I(X_{d};Y_{d},U_{d}) - I(X_{d};U_{d}) + I(Y_{d};X_{d},U_{d}) - I(Y_{d};U_{d}))}.
Discrete variables can be passed as factors
}
\examples{
library(miic)

N <- 1000 
# Dependence, conditional independence
Z <- runif(N)
X <- Z*2+rnorm(N,sd=0.2)
Y <- Z*2+rnorm(N,sd=0.2)
res <- discretizeMutual(X, Y, cplx="nml", plot=T)
cat("I(X;Y) =",res$info)
res <- discretizeMutual(X, Y, matrixU=matrix(Z, ncol=1), cplx="nml", plot=T)
cat("I(X;Y|Z) =",res$info)

# Conditional independence with categorical conditioning variable
Z <- sample(1:3, N, replace=T)
X <- -as.numeric(Z==1) + as.numeric(Z==2) + 0.2*rnorm(N)
Y <- as.numeric(Z==1) + as.numeric(Z==2) + 0.2*rnorm(N)
res <- miic::discretizeMutual(X, Y, cplx = 'nml')
cat("I(X;Y) =", res$info)
res <- miic::discretizeMutual(X, Y, matrix(Z,ncol=1), cplx='nml', is_discrete = c(F,F,T))
cat("I(X;Y|Z) =", res$info)


# Independence, conditional dependence
X <- runif(N)
Y <- runif(N)
Z <- X+Y
res <- discretizeMutual(X, Y, cplx="nml", plot=T)
cat("I(X;Y) =",res$info)
res <- discretizeMutual(X, Y, matrixU = matrix(Z, ncol=1), cplx="nml", plot=T)
cat("I(X;Y|Z) =",res$info)
}
